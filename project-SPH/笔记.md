day1

    1: vue-cli脚手架初始化项目
       node + webpack + 淘宝镜像
node_modules文件夹：项目依赖文件夹
public文件夹：一般放置静态资源(图片)，注意放在public文件夹的静态资源，webpack在进行打包的时候会原封不动的打包到dist文件夹中。
src文件夹(程序员源代码文件夹)：
    assets文件夹：一般也是放置静态资源(一边拿放置多个组件公用的静态资源)，需要注意放置到assets的静态资源在webpack打包的时候会把静态资源当作一个模块打包到JS文件里面

    components文件夹：一般放置的是非路由组件(全局组件)

    App.vue:唯一的跟组件，Vue当中的组件(.vue)
    main.js:程序的入口文件，也是程序中最先执行的文件
    .gitignore文件：git的忽略文件，一般不动
    
    babel.config.js:配置文件(bable相关)

    package.json文件：认为是项目的身份证，记录项目的信息，项目叫什么，项目当中的依赖，项目的运行

    package-lock.json：缓存性的文件

    vue.config.js：vue的配置文件


    2：项目的其他配置

    1.项目运行起来的时候浏览器自动打开
    在package.json里配置
     "scripts": {
    "serve": "vue-cli-service serve open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
                },

    2.eslint校验工具的关闭
    --vue.config.js配置文件
    比如声明变量未使用会被报错

    // 关闭eslint校验工具
    lintOnSave: false

    3. src文件夹目录的简写方式，即别名
        jsconfig.json配置别名@提示【@代表src文件夹，这样将来文件过多，找的时候方便很多】
        {
             "paths": {
                    "@/*": [
                    "src/*"
                        ]
                    },
        }

    3. 项目路由的分析
        vue-router
        前端所谓的路由：key value键值对。
        key： URL(地址栏中的路径)
        value：相对应的路由组件
        注意：项目上中下结构

        路由组件：
        Home首页路由组件，Search路由组件，Login登录路由(有Header,没有Footer)，Refister注册路由
        非路由组件：
        Header【首页，搜索页】
        Footer【在首页，搜索页，但是登录页没有|注册页，】

    4. 完成非路由组件Header与Footer业务
        在咱们的项目当中，不在以HTML + CSS为主，主要搞业务和逻辑
        在开发项目的时候
            1： 书写静态页面(HTML + CSS)
            2: 拆分组件
            3: 获取服务器的数据动态展示
            4: 完成相应的动态的业务逻辑

    注意1：创建组件的时候，组件的结构 + 组件的样式 + 组件的资源(图片)
    注意2：咱们的项目采用的是less样式，浏览器不识别less样式，需要采用less，less-loader进行处理
    注意3：如果想要组件识别less样式，需要在style标签身上加上lang="less"

    4.1 使用组件的步骤(非路由组件)
    -创建或定义路由
    -引入路由
    -注册路由
    -使用路由

    5. 路由组件的搭建
       1. 在上面分析的时候，路由组件应该有四个：Home，Search，Login，Register
       2. 安装vue-router插件  npm install --save vue-router@3     ---注意vue2版本支持vue-router@3版本的，vue3版本支持vue-router@4版本的
        -components文件夹：经常放置的是非路由组件，或者公用的全局组件
        -pages|views文件夹：经常放置路由组件

    5.1 配置路由
    项目当中配置的路由一般放置在router文件夹中

    5.2 总结
    路由组件与非路由组件的区别
    1：路由组件一般放置在pages|views文件夹，非路由组件一般放置在components文件夹中
    2：路由组件一般需要在router文件夹中进行注册（使用的即伟组件的名字），非路由组件在使用的时候一般都是以标签的形式使用
    3：注册完路由，不管是路由组件，还是非路由组件身上都有$route和$router属性


    $route: 一般获取路由信息[路径，query，params等等]
    $router: 一般进行编程式导航进行路由跳转【push | replace】

    5.3: 路由的跳转
    路由的跳转有两种形式：
    声明式导航router-link，可以进行路由的跳转
    编程式导航push|replace，可以进行路由跳转

    编程式导航：声明式导航能做的，编程式导航都能做
    但是编程式导航处理可以进行路由跳转，还可以做一些其他的业务逻辑

    6. Footer组件显示与隐藏
    显示或隐藏组件：v-if|v-show
    Footer组件：在Home，Search显示Footer组件
    Footer组件：在登录，注册的时候隐藏的

    6.1: 我们可以跟进组件身上的$route获取当前的路由信息，通过路由路径判断Footer显示与隐藏
    6.2: 配置路由的时候可以给路由添加路由元信息【meta】,路由需要配置对象，它的key不能瞎写，必须是已经存在的属性



    8：路由传参
    8.1：路由跳转有几种方式？
    比如：A -> B
    声明式导航： router-link（声明式导航必须有to属性），可以实现路由的跳转
    编程式导航：利用的是组件实例的$router.push | replace方法，可以实现路由的跳转，（可以书写一些自己的业务）

    8.2：路由传参，参数的写法有几种
    params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
    query参数：不属于路径中的一部分，类似于Ajax中的queryString--/home?k=v&kv=,不需要占位

    9:路由传参相关的面试题
    1：路由传递参数(对象写法)path是否可以结合params参数一起传递
    2：如何指定params参数可传可不传
    3:params参数可以传递也可以不传递，但是如果传递是空串，如何解决
    4：路由组件能不能传递props数据？



*** day2: 

    1:编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的错误警告？
    --路由跳转有两种形式：声明式导航，编程式导航
    --声明式导航没有这类问题的，因为vue-router底层已经处理好了

    1.1为什么编程式导航进行路由跳转的时候，就有这种警告错误呢？
     "vue-router": "^3.5.3"：最新的vue-router引入了promise
    1.2:通过给push方法传递相应的成功或者失败的回调函数，可以捕获到当前错误，可以解决，编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的错误警告

    1.3：通过底部的代码可以实现解决这个错误
   this.$router.push(
        {
          name: "search",
          params: { keyword: this.keyword || undefined },
          query: { k: this.keyword.toUpperCase() },
        },
        // 传递成功的回调
        () => {},
        // 传递失败的回调
        (error) => {
          console.log(error);
        }
      );
      这种写法：治标不治本，将来在别的组件中push|replace，编程式导航还是有类似的错误。

    1.4：
    this：当前组件实例（search）
    this.$router属性：当前的这个属性，属性值VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加的$route | $router属性
    push：VueRouter类的一个实例

    2:Home模块组件拆分
    --先把静态页面完成
    --拆分出静态组件
    --获取服务器的数据进行展示
    --动态业务

    3：三级联动组件完成
    ---由于三级联动在Home，Search，Detail都有，把三级联动注册为全局组件
    好处：只需要注册一次，就可以在项目任意地方使用
    4:完成其余静态组件
    HTML + CSS + 图片资源 ----细心【结构，样式，图片，资源缺一不可】

    最新接口地址：http://gmall-h5-api.atguigu.cn

    5:利用POSTMAN测试接口能不能正常使用
    --测试服务器接口没问题
    --如果服务器返回数据code字段200，代表服务器返回数据成功
    --整个项目，接口前缀都有/api字样

    6：axios二次封装

    XMLHttpRequest,fetch,JQ,axios

    6.1:为什么需要进行二次封装axios？
    请求拦截器，响应拦截器：请求拦截器，可以在发请求之前可以处理一些业务，响应拦截器，当服务器数据返回以后，可以处理一些事情

    6.2：在项目当中经常出现API文件夹【此文件夹就是和axios相关的
    
    6.3:如果axios的基础不好可以参考npm和git

    7:接口统一管理
    项目很小:完全可以在组件的生命周期函数种发请求

    项目大:必须做接口统一管理

    7.1:跨域问题
    什么是跨域:协议,域名,端口号不同请求,称之为跨域
     http://localhost:8080/------前端项目的本地服务器
     http://gmall-h5-api.atguigu.cn----获取资源的后台服务器

     解决跨域问题:JSONP,CROS,代理

    8:nprogress进度条的使用
    // 引入进度条
    import nprogress from 'nprogress'
    //start方法代表进度条开始,done方法:进度条结束
    // 引入进度条的样式
    import "nprogress/nprogress.css"
    进度条的颜色可以修改

    9:vuex状态管理库
    9.1:vuex是什么?
    vuex是官方提供的一个插件,状态管理库,集中式管理项目中组件的共用的数据
    切记:并不是全部项目都需要vuex,如果项目很小,完全不选哟vuex,如果项目很大,组件很多,数据很多数据维护很费劲就,需要vuex
    和vuex类似的state --mutations--actions--getters

    9.2:vuex的基本使用


    9.3:vuex实现模块式开发
    如果项目过大，组件过多，接口也很多，数据也很多，可以让vuex实现模块式开发


    10:完成TypeNav三级联动的动态数据，展示与获取
    [
        {
            id:1,
            name:"电子书"，
            child:[
                {
                    id:2,
                    name:"都联络"，
                    child:[
                        {},
                        {},
                        {}
                    ]
                },
                {
                    id:2,
                    name:"都联络"，
                    child:[
                        {},
                        {},
                        {}
                    ]
                },
            ]
        },
        {
            id:1,
            name:"电子书"，
            child:[
                {
                    id:2,
                    name:"都联络"，
                    child:[
                        {},
                        {},
                        {}
                    ]
                },
                {
                    id:2,
                    name:"都联络"，
                    child:[
                        {},
                        {},
                        {}
                    ]
                },
            ]
        },
    ]
    1):完成一级分类的背景颜色
    第一种解决方案：采用样式完成(可以的)
    第二种解决方案：通过JS完成

    2):通过JS控制二三级商品分类的显示与隐藏
    最开始的时候，是通过CSS样式display：block|none显示与隐藏二三级商品分类

    3):演示卡顿现象
    正常：事件触发非常频繁，而且每一次触发，回调函数都要去执行(如果时间很短，而回调函数内部有计算，那么可能出现浏览器卡顿)
    节流：在规定的间隔时间范围内不会出伏触发回调，只有大于这个时间间隔才会出大回调，把频繁触发为少量触发
    防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发  只会执行一次

    5）：完成三级联动的节流

    6）：三级联动组件的路由跳转与传递参数
    三级联动用户可以点击的：一级分类，二级分类，三级分类，当你点击的时候
    Home模块跳转到Search模块，一级会把用户选中的产品(产品的名字，产品的ID)在路由跳转的时候进行传递
    
    路由跳转：
    声明式导航：router-link
    编程式导航：push|replace

    三级联动，如果使用声明式导航router-link，可以实现路由的跳转和传递参数，但是会出现卡顿现象
    router-link：一个组件，当服务器的数据返回之后，循环从很多的router-link组件【创建组件实例的】所以卡顿
    在创建组件实例的时候，一瞬间创建1000+会出现卡顿

    *** day4:
    复习：
    1）：商品分类的三级列表由静态变为动态形式【获取服务器数据：解决跨域问题】
    2）：函数防抖与节流【面试频率很高】
    3）：路由跳转：声明式导航（router-link组件） | 编程式导航（回调函数，可以使用事件委托）













