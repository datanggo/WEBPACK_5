github账户密码 Rzl123123

ES6导入包的语法
import 定义名 from '包名'

webpack 的安装
 npm install webpack@5.42.1 webpack-cli@4.7.2 -D
配置webpack在项目的根目录中，创建名为webpack.config.js的webpack配置文件，
module.exports = {
	mode:'development' //mode用来指定构建模式，可选值有development和production
	在开发的时候用development模式，在发布的时候用production模式
	}
在package.json的scripts节点下，新增dev脚本如下
	"scripts":{
		"dev":"webpack"  //scripts  节点下的脚本，可以通过npm run执行，例如npm run dev
	}
在终端运行npm run dev 命令，启动webpack进行项目的打包构建
webpack中默认的约定
	在webpack4和5的版本中默认约定
	默认的打包入口文件为src ->index.js
	默认的输出文件路径为dist ->main.js
可以在webpack.config.js文件中修改默认设置
在webpack.config.js配置文件中，通过entry节点指定打包的入口，通过output节点指定打包的出口

webpack中的插件
webpack-dev-server
	类似于node.js阶段用的nodemon工具
	每当修改源代码，webpack会自动进行项目打包和构建
html-webpack-plugin
	webpack中html插件(类似于一个模板引擎插件)
	可以通过此插件自定制index.html页面的内容
安装插件
npm install webpack-dev-server@3.11.2 -D
npm install html-webpack-plugin
初始vue
        想让vue工作，就必须创建一个vue实例，且要传入一个配置对象
        root容器里的代码依然符合html规范，只不过混入了一些特殊的vue语法
        root容器里的代码称为【vue模板】
    注意区分：js表达式和js代码(语句)
        表达式：一个表达式可以生成一个值，可以放到任何一个需要值的地方
        js代码(语句)
            if(){}//for(){}
 /* data与el的2种写法
            el的两种写法
                1 new Vue时候配置el属性
                2 先创建Vue实例，随后再通过vm.$mount('#root')指定el的值
            data有2种写法
                1 对象式
                2 函数式
                如何选择：目前那种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错
            一个重要的原则：
                由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了 */
            /*  const v = new Vue({
                 //el: '#root',//第一种写法
                 data: {
                     name: '尚硅谷'
                 }
             })
             // 第二种方式
             console.log(v);
 
             v.$mount('#root') */

v-bind:    简写  ：
v-model:   简写 v-model
vue中的数据代理：
        通过vm对象来代理data对象中属性的操作（读/写）
    vue中数据代理的好处
        更加方便的操作data中的数据
    基本原理：
        通过Object.defineProperty()把data对象中所有属性添加到vm上
        为每一个添加到vm上的属性，都指定一个getter/setter
        在getter/setter内容去操作（读/写）data中对应的属性

vue中的修饰符
        1 prevent：阻止默认事件（常用）
        2 stop：阻止事件冒泡（常用）chud
        3 once 事件只触发一次（常用）
        4 capture 使用事件的捕获模式
        5 self 只有event.target是当前操作的元素是才触发事件
        6 passive 事件的默认行为立即执行，无需等待事件回调执行完毕

Vue中场用的按键别名
回车 => enter
删除 => delete (捕获‘删除’和‘退格’键)
退出 => esc
空格 => space
换行 => tab   （特殊必须配合 keydown使用）
上 => up
下 => down
左 => left
右 => right

Vue未提供别名的按键 可以使用按键原始值的key值去绑定，但注意要转换未kebab-case (短横线命名)

系统修饰键(用法特殊) ctrl，alt，shift，meta
    1 配合keyup使用：按下修时间的同时，再按下其他键，随后释放其他键，事件被触发
    2 配合keydown使用，正常触发事件
也可以使用keyCode去指定具体的按键(不推荐)

Vue.config.keyCode自定义键名 = 键码，可以去定制按键别名 

计算属性：
        1 定义：要用的属性不存在，要通过以右属性计算得来
        2 原理：底层借助了Objcet.defineproperty方法提供的getter和setter
        3 get函数什么时候执行
            1 初次读取时会执行
            2 当依赖的数据发生改变时会被再次调用
        4 优势 与methods实现相比，内部有缓存机制(方便复用)，效率更高，调试方便
        5 备注
            1 计算属性最终会出现在vm上，直接读取使用即可
            2 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算的依赖数据发生改变时要重新赋值

监视属性watch
1 当监视属性变化时，回调函数自动调用，进行相关的操作
2 监视的属性必须存在，才能进行监视
3 监视的两种写法
1 new vue时传入watch配置
2 通过vm.$watch监视

深度监视
        1 vue中的watch默认不监视对象内部的改变(一层)
        2 配置deep:true可以监视对象内部值改变(多层)
    备注：
        1 vue自身可以检测对象内部值的改变，但是vue提供的watch默认不可以
        2 使用watch时根据数据的具体结构，决定是否采用深度监视

 computed和watch之间的区别
            1 computed能完成的功能，watch都可以完成
            2 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作，即延迟操作
        
        两个重要的小原则
                1 所有被vue管理的函数，最好都用普通函数，这样this的指向才是vm 或组件实例对象
                2 所有不被vue管理的函数(定时器的回调函数，ajax的回调函数等，Promise的回调函数)，都最好写成箭头函数，
                这样this的指向才是vm 或组件实例对象

绑定样式  
        1 class样式
              写法：class="xxx"  xxx可以是字符串，对象，数组
                  字符串写法适用于：类名不确定，要动态获取
                  对象写法适用于：要绑定多个样式，个数不确定，名字也不确定
                  数组写法适用于：要绑定多个样式，个数确定名字也确定，但不确定用不用
        2 style样式
            :style="{fontSize ：xxx}" 其中xxx是动态值
            :style="[a,b]"其中a,b是样式对象

条件渲染：
1 v-if
写法：
1 v-if="表达式"
2 v-else-if="表达式"
3 v-else="表达式"
适用于：切换频率较低场景
特点：不展示的DOM元素直接移除
注意：v-if可以和v-else-if，v-else一起使用，但是要求结构不能被打断

2 v-show
写法：v-show="表达式"
适用于：切换频率较高的场景
特点：不展示DOM元素未被移除，仅仅是使用样式隐藏

备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到

v-for指令
1 用于展示列表数据
2 语法：v-for="(item,index) in xxx" :key="yyy"
3 可遍历：数组，对象，字符串(用的很少),指定次数(用的很少)

面试题 react，vue中的key有什么作用?(key的内部原理)
        1 虚拟DOM中key的作用
            key是虚拟DOM对象的标识，当数据发生变化时，vue会根据[新数据]生成[新的虚拟DOM]
            随后vue进行[新虚拟DOM]与[旧虚拟DOM]的差异比较，比较规则如下：

        2 对比规则
            1 旧虚拟DOM中找到了与新虚拟DOM相同的key：
                a 若虚拟DOM中内容没变，直接使用之前的真实DOM
                b 若虚拟DOM中内容变了 ，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

            2 旧虚拟DOM中未找到与新虚拟DOM相同的key
                创建新的真实DOM-随后渲染到页面
            
        3 用index作为key可能会引发问题
            1 若对数据进行：逆序添加，逆序删除等破坏顺序操作
                会产生没有必要的真实DOM更新 ==》 页面效果没问题，但是效率低
            
            2 如果结构中还包含输入类DOM
                会产生错误DOM更新 ==》 界面有问题
        
        4 开发中如何选中key：
            1 最好使用每条数据的唯一标识作为key 比如id，手机号，身份证号，学号等唯一值，
            2 如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
                使用index作为key是没有问题的

数组的操作：
            push()向数组后面追加元素
            pop()删除最后一个元素
            shift()删除第一个元素
            unshift()在最前面追加元素
            splice()操作(删除，追加，更改)指定位置的元素
            sort()对数组中的元素进行排序
            reverse()反转数组中的元素

Vue监视数据的原理
            1 vue会监视data中所有层次的数据
            
            2 如何检测对象中的数据？
                通过setter实现监视，且要在new Vue时就传入要检测的数据
                    1 对象中追加的属性，Vue默认不做响应式处理
                    2 如需给后添加的属性左响应式，请使用如下API
                            vue.set(target.propertyName/index, value)或
                            vm.$set(target.propertyName/index, value)

            3 如何检测数组中的数据
                通过包裹数组更新元素的方法实现，本质就是做了两件事
                    1 调用原生对应的方法对数组进行更新
                    2 重新解析模板，进而更新页面
            
            4 在Vue修改数组中的某个元素一定要用如下方法
                1 使用这些API：push(),pop(),shift(),unshift(),splice(),sort(),revers()
                2 vue.set() 或vm.$set()
            特别注意：vue.set()和vm.$set() 不能给vm或vm的根数据对象 添加属性！！！

收集表单中的-数据 
        若：<input type="text"> 则v-model收集的是value值，用户输入的就是value值
        若：<input type="radio">则v-model收集的是value值，且要给标签配置value值
        若：<input type="checkbox">
                1 没有配置input的value属性，那么收集的就是checked(勾选 or 未勾选，是布尔值)
                2 配置input的value属性
                    a v-model的初始值是非数组，那么收集的就是checked(勾选 or 未勾选，是布尔值)
                    b v-model的初始值是数组，那么收集的就是value组成的数组
        备注：v-model的三个修饰符
                lazy：失去焦点时再收集
                number：输入字符串转换为有效的数字
                trim：过滤掉输入的首尾空格
第三方库的网站  bootCDON  官网地址：https://www.bootcdn.cn/
第三方库：格式化时间库  dayjs

过滤器
          定义：对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)
          语法：
              1 注册过滤器：Vue.filter(name,callback) 或new Vue(filter:{})
              2 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = " xxx | 过滤器名"
          备注：
              1 过滤器也可以接收额外参数，多个过滤器也可以串联
              2 并没有改变原本的数据，是产生新的对应的数据

内置指令
        v-bind: 单向绑定解析表达式，可简写为  :xxx
        v-model: 双向数据绑定
        v-for:   遍历数组/对象/字符串
        v-on:   绑定事件监听，可简写为@
        v-if：  条件渲染(动态控制节点是否存在)   
        v-else: 条件渲染(动态控制节点是否存在)   
        v-show: 条件渲染(动态控制节点是否展示) 
v-text指令：
            1 作用：向其所在的节点中渲染文本内容
            2 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会
v-html指令
            1 作用：向指定节点中渲染包含html结构的内容
            2 与插值语法的区别：
                a:v-html会替换掉节点中所有的内容，{{xx}}则不会
                b:v-html可以识别html结构
            3 严重注意：v-html有安全性问题！！！！
                a:在网站上动态渲染任意html是非常危险的，容易导致xss攻击
                b:一定要在可信的内容上使用v-html，不要用在用户提交的内容上
 v-cloak指令(没有值)
            1 本质是一个特殊属性，vue实例创建完毕并接管容器后，会删掉v-cloak属性
            2 使用css配合[v-cloak]可以解决网速慢时页面展示出{{xxx}}的问题
v-once指令
            1 v-once所在的节点在初次动态渲染后，就视为静态内容了
            2 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能
v-pre指令
            1 跳过其所在节点的编译过程
            2 可以利用它跳过：没有使用指令语法，没有使用插值语法的节点，会加快编译
自定义指令总结
          一   定义语法
              1 局部指令：
                  new Vue({                               new Vue({
                    directives:{指令名：配置对象}     或      directives{指令名：回调函数}
                  })                                      })
              2 全局指令：
                  Vue.directive(指令名，配置对象)    或    Vue.directive(指令名，回调函数)
          二  配置对象中常用的3个回调
              1 bind：指令与元素成功时调用
              2 inserted:指令所在元素被插入页面时调用
              3 update：指令所在模板结构被重新解析时调用
          三  备注
              1 指令定义时不加v-,但使用时要加v-；
              2 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名
              
生命周期：
        1 又名：生命周期回调函数，生命周期函数，生命周期钩子
        2 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数
        3 生命周期函数的名字不可改变，但函数的具体内容是程序员根据需求编写的
        4 生命周期函数中的this指向是vm 或组件实例对象
vm的一生(vm的生命周期)
            将要创建 ===> 调用beforeCreate函数
            创建完毕 ===> 调用created函数
            将要挂载 ===> 调用beforeMount函数
        (重要)挂载完毕 ===> 调用mounted函数。=========>[重要的钩子]
            将要更新 ===> 调用beforeUpdate函数。
            更新完毕 ===> 调用updated函数。
        (重要)将要销毁 ===> 调用beforeDestroy函数。======>[重要的钩子]
            销毁完毕 ===> 调用destroyed函数
常用的生命周期钩子
            1 mounted：发生ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】
            2 beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】

        关于销毁vue实例
            1 销毁后借助vue开发者工具看不到任何消息
            2 销毁后自定义事件会失败，但原生DOM事件依然有效
            3 一般不会再berforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了

组件
	组件的定义：即实现应用中局部功能代码和资源的集合
非单文件组件
	一个文件中包含有n个组件
单文件组件
	一个文件中只包含一个组件
vue中使用组件的三大步骤：
            一，定义组件(创建组件)
            二，注册组件
            三，使用组件(写组件标签)
        一，如何定义一个组件？
            使用vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但区别如下
                1 el不要写，为什么？__最终所有的组件都要经过一个vm的管理，由vm中的el指定服务对象
                2 data必须写成函数，为什么？__避免组件被复用时，数据存在引用关系
            备注：使用template可以配置组件结构
        二，如何注册组件？
            1 局部注册：靠new Vue的时候传入components选项
            2 全局注册:靠vue.component("组件名"，组件)
        三，编写组件标签
            <school></school>
几个注意点：
            1 关于组件名：
                一个单词
                    第一种写法(首字母小写)school
                    第二种写法(首字母大写)School
                多个单词
                    第一种写法(kebab-case命名)：my-school
                    第二种写法(CamelCase命名)：MySchool(需要vue脚手架支持)
                备注：
                    1 组件名尽可能回避HTML中已有的元素名称，例如，h2,H2都不行
                    2 可以使用name配置项指定组件在开发者工具中呈现的名字
            2 关于组件标签：
                第一种写法：<school></school>
                第二种写法：<school/>
                备注：不要使用脚手架时，<school/>会导致后续组件不能渲染

            3 一个简写形式
                const school = Vue.extend(options)可简写为：const school = options
关于VueComponent:
            1 school组件本质是一个名为VueComponent的构造函数，并且不是程序员定义的，是Vue.extend生成的
            2 我们只需要写<school></school>或者<school/>,Vue解析时会帮我们创建school组件的实例对象
            即Vue帮我们执行的：new VueComponent(options)
            3 特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent！！！！
            4 关于this指向
                a 组件配置中
                        data函数，methods中的函数，watch中的函数，computed中的函数 它们的this均是【VueComponent实例对象】
                b new Vue()配置中：
                        data函数，methods中的函数，watch中的函数，computed中的函数 它们的this均是【Vue实例对象】
            5 VueComponent的实例对象，以后简称vc（也可称为：组件实例对象）
            Vue的实例对象，以后简称vm
1 一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype
2 为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性，方法

vue cli  即vue脚手架
	安装全局包   @vue/cli
	npm install -g @vue/cli
	切换到你要创建项目的目录，使用命令创建项目
	vue create xxxx
	启动项目
	npm run serve
注意：
	如果出现下载缓慢配置npm 淘宝镜像 npm config set registry
	https://registry.npm.taobao.org
	
	vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行vue inspact > output.js

ES6模块化
	向外暴露方式
	1  export let a = 1	分别暴露
	2  let a = 1； let b =3；
	    export { a  , b }	统一暴露
	3  let c = 20
	    export default c    默认暴露
	引入外部组件
	import { a as d } from "./index.js"	分别暴露的对象
	import { a as f ，b } from "./index.js" 统一暴露的对象
	import  c from "./index.js"	默认暴露的对象   
CommonJS模块化
	向外暴露方式
	module.exports对象
	在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用
	引入外部组件
	外界用require()方法导入自定义模块，得到的就是module.exports所指向的对象
	let a = 20;
	let a = require("../index.js")


## 脚手架文件结构：
|—— node_modules
|—— public
|    |—— favicon.ico: 页签图标
|    |—— index.html: 主页面
|—— src
|    |—— assets: 存放静态资源
|    |    |——logo.png
|    |—— component: 存放组件
|    |    |——HelloWord.vue
|    |—— App.vue: 汇总所有组件
|    |—— main.js：入口文件
|—— .gitignore: git版本管制忽略的配置文件
|—— babel.config.js: babel的配置文件
|—— package.json: 应用包配置文件
|—— README.md: 应用描述文件
|—— package.lock.json: 包版本控制文件

## 关于不同版本的vue
    - vue.js与vu.runtime.xxx.js的区别：
            1 vue.js是完整的vue，包含：核心功能+模板解析器
            2 vue.runtime.xxx.js是运行版本的vue，只包含：核心功能：没有模板解析器
    - 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到createElement函数去指定具体内容
  
## vue.config.js配置文件
> 使用vue.inspect > output.js可以查看到vue脚手架的默认配置
> 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh

## ref属性
    1.被用来给元素或子组件注册引用信息(id的替代者)
    2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc)
    3.使用方式：
        打标识：<h1 ref="xxx">....</h1>或<School ref="xxx"></School>
        获取：this.$refs.xxx
## 配置项props
    功能：让组件接收外部传过来的数据
        1.传递数据：
            <Demo name="xxx"/>
        2.接收数据
            第一种方式(只接收)：
                props：["name"]
            第二种方式(限制类型)
                props：{
                    name：String
                }
            第三种方式(限制类型，限制必要性，指定默认值)
                props：{
                    name:{
                        type:String， //类型
                        required:true, //必要性
                        default:'老王'  //默认值
                    }
                }
    备注：props是只读，vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
        若业务需求确实需要修改，那么请赋值props的内容到data中一份，然后去修改data中的数据。
## mixin(混入)
    功能：可以把多个组件共用的配置提取成一个混入对象
    使用方式：
        第一步定义混合，例如：
        {
            data(){....},
            metnods:{....}
            ....
        }
        第二步使用混入，例如：
        1.全局混入：Vue.mixin(xxx)
        2.局部混入：mixins:['xxx']
## 插件
    功能：用于增强Vue
    本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。
    定义插件：
        对象.install = function(Vue,options) {
            // 1.添加全局过滤器
            Vue.filter(...)

            // 2.添加全局指令
             Vue.directive(...)

            // 3.配置全局混入
            Vue.mixin(....)

            // 4.添加实例方法
            Vue.prototype.$myMethod = function(){...}
            Vue.prototype.$myProperty = xxx

        }
    使用插件：Vue.use()

## 样式注意点
    <style lang="css">  表示style标签里的都是css内容
    </style>
    <style lang="less">  表示style标签里的都是less语言编译的
    </style>
<style scoped>  表示style标签里的所有代码仅服务于当前文件，即作用域的原理，组件开发中常用于除app文件外的其他组件内，防止样式名互相影响
    </style>

npm view webpack versions
可以快速查找指定包的所有的版本

## 总结 todolist 案例

1.组件化编码流程：
			(1). 拆分静态组件，组件要按照功能点拆分，命名不要与 html 元素冲突
			(2). 实现动态组件，考虑好数据的存放位置，数据是一个组件在用还是一些组件在用：
						1]. 一个组件在用：放在组件自身即可
						2]. 一些组件要用：放在他们共同的父组件上(<span style="color:red">状态提升</span>)
			(3).实现交互：从绑定事件开始
2.props 适用于：
			(1).父组件===》子组件 通信
			(2).子组件===》父组件 通信 (要求父组件先给子组件传一个函数，通过函数传参进行交互)

3.使用 v-model 时要切记：v-model 绑定的值不能时 props 传过来的值，因为 props 是不可以修改的！
4.props 传过来的若是对象类型的值 修改对象中的属性时 vue 不会报错。但不推荐这样做！！！！

## webStorage本地存储local/会话存储session

1. 存储内容大小一般支持5MB作用(不同浏览器可能不一样)
2. 浏览器端通过Window.sessionStorage和window.localStorage属性来实现本地存储机制
3. 相关API：
   1. xxxxxStorage.setItme("key","val")
        该方法接收一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值.
    2. xxxxStorage.getItme("person")
        该方法接收一个键名作为参数，返回键名对应的值
    3. xxxxxStorage.removeItme("key")
        该方法接收一个键名作为参数，并把键名从存储中删除
    4. xxxxxStorage.clear()
        该方法会清空存储中的所有数据
4. 备注
    1. sessionStorage存储的内容会随着浏览器窗口关闭而消失
    2. localStorage存储的内容，需要手动清除才会消失
    3. xxxxxStorage.getItme(xxx)如果xxx对应的value获取不到，那么getItme的返回值是null
    4. JSON.parse(null)的结果依然是null

## 组件的自定义事件
1. 一种组件间通信的方式，适用于：子组件 ===> 父组件
2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件(事件的回调在A中)
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：<Demo @guigu="test"/>或<Demo v-on:guigu="test">
   2. 第二种方式，在父组件中：
        <Demo ref="demo"/>
        ....
        mounted(){
            this.$refs.xxx.$on("guigu",this.name)
        }
    3. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法
4. 触发自定义事件：this.$emit("guigu",数据)
5. 解绑自定义事件this.$off("guigu")
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符
7. 注意：通过this.$refs.xxx.$on("guigu",回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出现问题！！！

## 全局事件总线(GlobalEventBus)

1. 一种组件间通信的方式，适用于任意组件间通信
2. 安装全局事件总线：
        new Vue({
            .....
            beforeCreate(){
                Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
            }
            ......
        })
3. 使用事件总线：
   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身
    methods(){
        demo(data){.....}
    }
    ......
    mounted(){
        this.$bus.$on("xxxx",this.demo)
    }
    2. 提供数据：this.$bus.$emit("xxxx",数据)
4. 最好在beforeDestroy钩子，用$off去解绑当前组件所用到的事件

## 消息订阅与发布(pubsub)
1. 一种组件间通信的方式，适用于任意组件间通信
2. 使用步骤：
   1. 安装pubsub： npm i pubsub-js
   2. 引入： import pubsub from "pubsub-js"
   3. 接收数据：A组件想接收数据，则A组件中订阅消息，订阅的回调留在A组件自身
        methods(){
            demo(data){......}
        },
        ......
        mounted(){
            this.pid = pubsub.subscribe("xxx",this.demo) //订阅消息
        }
    4. 提供数据：pubsub.publish("xxx",数据)
    5. 最好在beforeDestroy钩子，用PubSub.unsubscribe(pid)去<span style="color:red">取消订阅</span>

## nextTick

1. 语法：this.$nextTick(回调函数)
2. 作用：在下一次DOM更新接收后执行其指定的回调
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行

## Vue封装的过渡与动画

1. 作用：在插入，更新或移除DOM元素时，在合适的时候给元素添加样式类名
2. 图示：

          Enter                            leave
           ||                                ||
      opacity:0     opacity:1            opacity:1        opacity:0
          |           |                       |               |
      v-enter     v-enter-to              v-leave           v-leave-to

      ----------------------              ---------------------------
                  |                        |
          v-enter-active             v-leave-active

3. 写法：
   1. 准备好样式：
        · 元素进入的样式
            1. v-enter：进入的起点
            2. v-enter-active: 进入过程中
            3. v-enter-to: 进入的终点
        · 元素离开的样式
            4. v-leave：离开的起点
            5. v-leave-active：离开的过程中
            6. v-leave-to： 离开的终点
   2. 使用<transition>包裹要过渡的元素，并配置name属性
        <transition name="hello">
            <h1 v-show="isShow">你好啊！</h1>
        </transition>
    3. 备注：若有多个元素需要过渡，则需要使用：<transition-group>,且每个元素都有指定key值

vue-router@3版本支持vue2
vue-router@4版本支持vue3
vuex@3版本支持vue2
vuex@4版本支持vue3





	






