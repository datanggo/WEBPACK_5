github账户密码 Rzl123123

ES6导入包的语法
import 定义名 from '包名'

webpack 的安装
 npm install webpack@5.42.1 webpack-cli@4.7.2 -D
配置webpack在项目的根目录中，创建名为webpack.config.js的webpack配置文件，
module.exports = {
	mode:'development' //mode用来指定构建模式，可选值有development和production
	在开发的时候用development模式，在发布的时候用production模式
	}
在package.json的scripts节点下，新增dev脚本如下
	"scripts":{
		"dev":"webpack"  //scripts  节点下的脚本，可以通过npm run执行，例如npm run dev
	}
在终端运行npm run dev 命令，启动webpack进行项目的打包构建
webpack中默认的约定
	在webpack4和5的版本中默认约定
	默认的打包入口文件为src ->index.js
	默认的输出文件路径为dist ->main.js
可以在webpack.config.js文件中修改默认设置
在webpack.config.js配置文件中，通过entry节点指定打包的入口，通过output节点指定打包的出口

webpack中的插件
webpack-dev-server
	类似于node.js阶段用的nodemon工具
	每当修改源代码，webpack会自动进行项目打包和构建
html-webpack-plugin
	webpack中html插件(类似于一个模板引擎插件)
	可以通过此插件自定制index.html页面的内容
安装插件
npm install webpack-dev-server@3.11.2 -D
npm install html-webpack-plugin
初始vue
        想让vue工作，就必须创建一个vue实例，且要传入一个配置对象
        root容器里的代码依然符合html规范，只不过混入了一些特殊的vue语法
        root容器里的代码称为【vue模板】
    注意区分：js表达式和js代码(语句)
        表达式：一个表达式可以生成一个值，可以放到任何一个需要值的地方
        js代码(语句)
            if(){}//for(){}
 /* data与el的2种写法
            el的两种写法
                1 new Vue时候配置el属性
                2 先创建Vue实例，随后再通过vm.$mount('#root')指定el的值
            data有2种写法
                1 对象式
                2 函数式
                如何选择：目前那种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错
            一个重要的原则：
                由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了 */
            /*  const v = new Vue({
                 //el: '#root',//第一种写法
                 data: {
                     name: '尚硅谷'
                 }
             })
             // 第二种方式
             console.log(v);
 
             v.$mount('#root') */

v-bind:    简写  ：
v-model:   简写 v-model
vue中的数据代理：
        通过vm对象来代理data对象中属性的操作（读/写）
    vue中数据代理的好处
        更加方便的操作data中的数据
    基本原理：
        通过Object.defineProperty()把data对象中所有属性添加到vm上
        为每一个添加到vm上的属性，都指定一个getter/setter
        在getter/setter内容去操作（读/写）data中对应的属性

vue中的修饰符
        1 prevent：阻止默认事件（常用）
        2 stop：阻止事件冒泡（常用）chud
        3 once 事件只触发一次（常用）
        4 capture 使用事件的捕获模式
        5 self 只有event.target是当前操作的元素是才触发事件
        6 passive 事件的默认行为立即执行，无需等待事件回调执行完毕

Vue中场用的按键别名
回车 => enter
删除 => delete (捕获‘删除’和‘退格’键)
退出 => esc
空格 => space
换行 => tab   （特殊必须配合 keydown使用）
上 => up
下 => down
左 => left
右 => right

Vue未提供别名的按键 可以使用按键原始值的key值去绑定，但注意要转换未kebab-case (短横线命名)

系统修饰键(用法特殊) ctrl，alt，shift，meta
    1 配合keyup使用：按下修时间的同时，再按下其他键，随后释放其他键，事件被触发
    2 配合keydown使用，正常触发事件
也可以使用keyCode去指定具体的按键(不推荐)

Vue.config.keyCode自定义键名 = 键码，可以去定制按键别名 

计算属性：
        1 定义：要用的属性不存在，要通过以右属性计算得来
        2 原理：底层借助了Objcet.defineproperty方法提供的getter和setter
        3 get函数什么时候执行
            1 初次读取时会执行
            2 当依赖的数据发生改变时会被再次调用
        4 优势 与methods实现相比，内部有缓存机制(方便复用)，效率更高，调试方便
        5 备注
            1 计算属性最终会出现在vm上，直接读取使用即可
            2 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算的依赖数据发生改变时要重新赋值

监视属性watch
1 当监视属性变化时，回调函数自动调用，进行相关的操作
2 监视的属性必须存在，才能进行监视
3 监视的两种写法
1 new vue时传入watch配置
2 通过vm.$watch监视

深度监视
        1 vue中的watch默认不监视对象内部的改变(一层)
        2 配置deep:true可以监视对象内部值改变(多层)
    备注：
        1 vue自身可以检测对象内部值的改变，但是vue提供的watch默认不可以
        2 使用watch时根据数据的具体结构，决定是否采用深度监视

 computed和watch之间的区别
            1 computed能完成的功能，watch都可以完成
            2 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作，即延迟操作
        
        两个重要的小原则
                1 所有被vue管理的函数，最好都用普通函数，这样this的指向才是vm 或组件实例对象
                2 所有不被vue管理的函数(定时器的回调函数，ajax的回调函数等，Promise的回调函数)，都最好写成箭头函数，
                这样this的指向才是vm 或组件实例对象

绑定样式  
        1 class样式
              写法：class="xxx"  xxx可以是字符串，对象，数组
                  字符串写法适用于：类名不确定，要动态获取
                  对象写法适用于：要绑定多个样式，个数不确定，名字也不确定
                  数组写法适用于：要绑定多个样式，个数确定名字也确定，但不确定用不用
        2 style样式
            :style="{fontSize ：xxx}" 其中xxx是动态值
            :style="[a,b]"其中a,b是样式对象

条件渲染：
1 v-if
写法：
1 v-if="表达式"
2 v-else-if="表达式"
3 v-else="表达式"
适用于：切换频率较低场景
特点：不展示的DOM元素直接移除
注意：v-if可以和v-else-if，v-else一起使用，但是要求结构不能被打断

2 v-show
写法：v-show="表达式"
适用于：切换频率较高的场景
特点：不展示DOM元素未被移除，仅仅是使用样式隐藏

备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到

v-for指令
1 用于展示列表数据
2 语法：v-for="(item,index) in xxx" :key="yyy"
3 可遍历：数组，对象，字符串(用的很少),指定次数(用的很少)

面试题 react，vue中的key有什么作用?(key的内部原理)
        1 虚拟DOM中key的作用
            key是虚拟DOM对象的标识，当数据发生变化时，vue会根据[新数据]生成[新的虚拟DOM]
            随后vue进行[新虚拟DOM]与[旧虚拟DOM]的差异比较，比较规则如下：

        2 对比规则
            1 旧虚拟DOM中找到了与新虚拟DOM相同的key：
                a 若虚拟DOM中内容没变，直接使用之前的真实DOM
                b 若虚拟DOM中内容变了 ，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

            2 旧虚拟DOM中未找到与新虚拟DOM相同的key
                创建新的真实DOM-随后渲染到页面
            
        3 用index作为key可能会引发问题
            1 若对数据进行：逆序添加，逆序删除等破坏顺序操作
                会产生没有必要的真实DOM更新 ==》 页面效果没问题，但是效率低
            
            2 如果结构中还包含输入类DOM
                会产生错误DOM更新 ==》 界面有问题
        
        4 开发中如何选中key：
            1 最好使用每条数据的唯一标识作为key 比如id，手机号，身份证号，学号等唯一值，
            2 如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
                使用index作为key是没有问题的

数组的操作：
            push()向数组后面追加元素
            pop()删除最后一个元素
            shift()删除第一个元素
            unshift()在最前面追加元素
            splice()操作(删除，追加，更改)指定位置的元素
            sort()对数组中的元素进行排序
            reverse()反转数组中的元素

Vue监视数据的原理
            1 vue会监视data中所有层次的数据
            
            2 如何检测对象中的数据？
                通过setter实现监视，且要在new Vue时就传入要检测的数据
                    1 对象中追加的属性，Vue默认不做响应式处理
                    2 如需给后添加的属性左响应式，请使用如下API
                            vue.set(target.propertyName/index, value)或
                            vm.$set(target.propertyName/index, value)

            3 如何检测数组中的数据
                通过包裹数组更新元素的方法实现，本质就是做了两件事
                    1 调用原生对应的方法对数组进行更新
                    2 重新解析模板，进而更新页面
            
            4 在Vue修改数组中的某个元素一定要用如下方法
                1 使用这些API：push(),pop(),shift(),unshift(),splice(),sort(),revers()
                2 vue.set() 或vm.$set()
            特别注意：vue.set()和vm.$set() 不能给vm或vm的根数据对象 添加属性！！！

收集表单中的-数据 
        若：<input type="text"> 则v-model收集的是value值，用户输入的就是value值
        若：<input type="radio">则v-model收集的是value值，且要给标签配置value值
        若：<input type="checkbox">
                1 没有配置input的value属性，那么收集的就是checked(勾选 or 未勾选，是布尔值)
                2 配置input的value属性
                    a v-model的初始值是非数组，那么收集的就是checked(勾选 or 未勾选，是布尔值)
                    b v-model的初始值是数组，那么收集的就是value组成的数组
        备注：v-model的三个修饰符
                lazy：失去焦点时再收集
                number：输入字符串转换为有效的数字
                trim：过滤掉输入的首尾空格
第三方库的网站  bootCDON  官网地址：https://www.bootcdn.cn/
第三方库：格式化时间库  dayjs

过滤器
          定义：对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)
          语法：
              1 注册过滤器：Vue.filter(name,callback) 或new Vue(filter:{})
              2 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = " xxx | 过滤器名"
          备注：
              1 过滤器也可以接收额外参数，多个过滤器也可以串联
              2 并没有改变原本的数据，是产生新的对应的数据

内置指令
        v-bind: 单向绑定解析表达式，可简写为  :xxx
        v-model: 双向数据绑定
        v-for:   遍历数组/对象/字符串
        v-on:   绑定事件监听，可简写为@
        v-if：  条件渲染(动态控制节点是否存在)   
        v-else: 条件渲染(动态控制节点是否存在)   
        v-show: 条件渲染(动态控制节点是否展示) 
v-text指令：
            1 作用：向其所在的节点中渲染文本内容
            2 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会
v-html指令
            1 作用：向指定节点中渲染包含html结构的内容
            2 与插值语法的区别：
                a:v-html会替换掉节点中所有的内容，{{xx}}则不会
                b:v-html可以识别html结构
            3 严重注意：v-html有安全性问题！！！！
                a:在网站上动态渲染任意html是非常危险的，容易导致xss攻击
                b:一定要在可信的内容上使用v-html，不要用在用户提交的内容上
 v-cloak指令(没有值)
            1 本质是一个特殊属性，vue实例创建完毕并接管容器后，会删掉v-cloak属性
            2 使用css配合[v-cloak]可以解决网速慢时页面展示出{{xxx}}的问题
v-once指令
            1 v-once所在的节点在初次动态渲染后，就视为静态内容了
            2 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能
v-pre指令
            1 跳过其所在节点的编译过程
            2 可以利用它跳过：没有使用指令语法，没有使用插值语法的节点，会加快编译
自定义指令总结
          一   定义语法
              1 局部指令：
                  new Vue({                               new Vue({
                    directives:{指令名：配置对象}     或      directives{指令名：回调函数}
                  })                                      })
              2 全局指令：
                  Vue.directive(指令名，配置对象)    或    Vue.directive(指令名，回调函数)
          二  配置对象中常用的3个回调
              1 bind：指令与元素成功时调用
              2 inserted:指令所在元素被插入页面时调用
              3 update：指令所在模板结构被重新解析时调用
          三  备注
              1 指令定义时不加v-,但使用时要加v-；
              2 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名
              
生命周期：
        1 又名：生命周期回调函数，生命周期函数，生命周期钩子
        2 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数
        3 生命周期函数的名字不可改变，但函数的具体内容是程序员根据需求编写的
        4 生命周期函数中的this指向是vm 或组件实例对象
vm的一生(vm的生命周期)
            将要创建 ===> 调用beforeCreate函数
            创建完毕 ===> 调用created函数
            将要挂载 ===> 调用beforeMount函数
        (重要)挂载完毕 ===> 调用mounted函数。=========>[重要的钩子]
            将要更新 ===> 调用beforeUpdate函数。
            更新完毕 ===> 调用updated函数。
        (重要)将要销毁 ===> 调用beforeDestroy函数。======>[重要的钩子]
            销毁完毕 ===> 调用destroyed函数
常用的生命周期钩子
            1 mounted：发生ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】
            2 beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】

        关于销毁vue实例
            1 销毁后借助vue开发者工具看不到任何消息
            2 销毁后自定义事件会失败，但原生DOM事件依然有效
            3 一般不会再berforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了

组件
	组件的定义：即实现应用中局部功能代码和资源的集合
非单文件组件
	一个文件中包含有n个组件
单文件组件
	一个文件中只包含一个组件
vue中使用组件的三大步骤：
            一，定义组件(创建组件)
            二，注册组件
            三，使用组件(写组件标签)
        一，如何定义一个组件？
            使用vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但区别如下
                1 el不要写，为什么？__最终所有的组件都要经过一个vm的管理，由vm中的el指定服务对象
                2 data必须写成函数，为什么？__避免组件被复用时，数据存在引用关系
            备注：使用template可以配置组件结构
        二，如何注册组件？
            1 局部注册：靠new Vue的时候传入components选项
            2 全局注册:靠vue.component("组件名"，组件)
        三，编写组件标签
            <school></school>
几个注意点：
            1 关于组件名：
                一个单词
                    第一种写法(首字母小写)school
                    第二种写法(首字母大写)School
                多个单词
                    第一种写法(kebab-case命名)：my-school
                    第二种写法(CamelCase命名)：MySchool(需要vue脚手架支持)
                备注：
                    1 组件名尽可能回避HTML中已有的元素名称，例如，h2,H2都不行
                    2 可以使用name配置项指定组件在开发者工具中呈现的名字
            2 关于组件标签：
                第一种写法：<school></school>
                第二种写法：<school/>
                备注：不要使用脚手架时，<school/>会导致后续组件不能渲染

            3 一个简写形式
                const school = Vue.extend(options)可简写为：const school = options
关于VueComponent:
            1 school组件本质是一个名为VueComponent的构造函数，并且不是程序员定义的，是Vue.extend生成的
            2 我们只需要写<school></school>或者<school/>,Vue解析时会帮我们创建school组件的实例对象
            即Vue帮我们执行的：new VueComponent(options)
            3 特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent！！！！
            4 关于this指向
                a 组件配置中
                        data函数，methods中的函数，watch中的函数，computed中的函数 它们的this均是【VueComponent实例对象】
                b new Vue()配置中：
                        data函数，methods中的函数，watch中的函数，computed中的函数 它们的this均是【Vue实例对象】
            5 VueComponent的实例对象，以后简称vc（也可称为：组件实例对象）
            Vue的实例对象，以后简称vm
1 一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype
2 为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性，方法

vue cli  即vue脚手架
	安装全局包   @vue/cli
	npm install -g @vue/cli
	切换到你要创建项目的目录，使用命令创建项目
	vue create xxxx
	启动项目
	npm run serve
注意：
	如果出现下载缓慢配置npm 淘宝镜像 npm config set registry
	https://registry.npm.taobao.org
	
	vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行vue inspact > output.js







