# 笔记

## 脚手架文件结构：

|—— node_modules
|—— public
| |—— favicon.ico: 页签图标
| |—— index.html: 主页面
|—— src
| |—— assets: 存放静态资源
| | |——logo.png
| |—— component: 存放组件
| | |——HelloWord.vue
| |—— App.vue: 汇总所有组件
| |—— main.js：入口文件
|—— .gitignore: git 版本管制忽略的配置文件
|—— babel.config.js: babel 的配置文件
|—— package.json: 应用包配置文件
|—— README.md: 应用描述文件
|—— package.lock.json: 包版本控制文件

## 关于不同版本的 vue

    - vue.js与vu.runtime.xxx.js的区别：
            1 vue.js是完整的vue，包含：核心功能+模板解析器
            2 vue.runtime.xxx.js是运行版本的vue，只包含：核心功能：没有模板解析器
    - 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到createElement函数去指定具体内容

## vue.config.js 配置文件

> 使用 vue.inspect > output.js 可以查看到 vue 脚手架的默认配置
> 使用 vue.config.js 可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh

## ref 属性

    1.被用来给元素或子组件注册引用信息(id的替代者)
    2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc)
    3.使用方式：
        打标识：<h1 ref="xxx">....</h1>或<School ref="xxx"></School>
        获取：this.$refs.xxx

## 配置项 props

    功能：让组件接收外部传过来的数据
        1.传递数据：
            <Demo name="xxx"/>
        2.接收数据
            第一种方式(只接收)：
                props：["name"]
            第二种方式(限制类型)
                props：{
                    name：String
                }
            第三种方式(限制类型，限制必要性，指定默认值)
                props：{
                    name:{
                        type:String， //类型
                        required:true, //必要性
                        default:'老王'  //默认值
                    }
                }
    备注：props是只读，vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
        若业务需求确实需要修改，那么请赋值props的内容到data中一份，然后去修改data中的数据。

## mixin(混入)

    功能：可以把多个组件共用的配置提取成一个混入对象
    使用方式：
        第一步定义混合，例如：
        {
            data(){....},
            metnods:{....}
            ....
        }
        第二步使用混入，例如：
        1.全局混入：Vue.mixin(xxx)
        2.局部混入：mixins:['xxx']

## 插件

    功能：用于增强Vue
    本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。
    定义插件：
        对象.install = function(Vue,options) {
            // 1.添加全局过滤器
            Vue.filter(...)
    
            // 2.添加全局指令
             Vue.directive(...)
    
            // 3.配置全局混入
            Vue.mixin(....)
    
            // 4.添加实例方法
            Vue.prototype.$myMethod = function(){...}
            Vue.prototype.$myProperty = xxx
    
        }
    使用插件：Vue.use()

## 样式注意点

```js
<style lang="css">  表示style标签里的都是css内容
</style>
<style lang="less">  表示style标签里的都是less语言编译的
</style>
```

## scoped 样式

作用：让样式在局部生效，防止命名冲突
写法：<style scoped></style>

## 总结 todolist 案例

1.组件化编码流程：
(1). 拆分静态组件，组件要按照功能点拆分，命名不要与 html 元素冲突
(2). 实现动态组件，考虑好数据的存放位置，数据是一个组件在用还是一些组件在用：
1]. 一个组件在用：放在组件自身即可
2]. 一些组件要用：放在他们共同的父组件上(<span style="color:red">状态提升</span>)
(3).实现交互：从绑定事件开始
2.props 适用于：
(1).父组件===》子组件 通信
(2).子组件===》父组件 通信 (要求父组件先给子组件传一个函数，通过函数传参进行交互)

3.使用 v-model 时要切记：v-model 绑定的值不能时 props 传过来的值，因为 props 是不可以修改的！
4.props 传过来的若是对象类型的值 修改对象中的属性时 vue 不会报错。但不推荐这样做！！！！

## webStorage 本地存储 local/会话存储 session

1. 存储内容大小一般支持 5MB 作用(不同浏览器可能不一样)
2. 浏览器端通过 Window.sessionStorage 和 window.localStorage 属性来实现本地存储机制
3. 相关 API：
   1. xxxxxStorage.setItme("key","val")
      该方法接收一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值.
   2. xxxxStorage.getItme("person")
      该方法接收一个键名作为参数，返回键名对应的值
   3. xxxxxStorage.removeItme("key")
      该方法接收一个键名作为参数，并把键名从存储中删除
   4. xxxxxStorage.clear()
      该方法会清空存储中的所有数据
4. 备注
   1. sessionStorage 存储的内容会随着浏览器窗口关闭而消失
   2. localStorage 存储的内容，需要手动清除才会消失
   3. xxxxxStorage.getItme(xxx)如果 xxx 对应的 value 获取不到，那么 getItme 的返回值是 null
   4. JSON.parse(null)的结果依然是 null

## 组件的自定义事件

1. 一种组件间通信的方式，适用于：子组件 ===> 父组件
2. 使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件(事件的回调在 A 中)
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：<Demo @guigu="test"/>或<Demo v-on:guigu="test">
   2. 第二种方式，在父组件中：
      <Demo ref="demo"/>
      ....
      mounted(){
      this.$refs.xxx.$on("guigu",this.name)
      }
   3. 若想让自定义事件只能触发一次，可以使用 once 修饰符，或$once 方法
4. 触发自定义事件：this.$emit("guigu",数据)
5. 解绑自定义事件 this.$off("guigu")
6. 组件上也可以绑定原生 DOM 事件，需要使用 native 修饰符
7. 注意：通过 this.$refs.xxx.$on("guigu",回调)绑定自定义事件时，回调要么配置在 methods 中，要么用箭头函数，否则 this 指向会出现问题！！！

## 全局事件总线(GlobalEventBus)

1. 一种组件间通信的方式，适用于任意组件间通信
2. 安装全局事件总线：
   new Vue({
   .....
   beforeCreate(){
   Vue.prototype.$bus = this //安装全局事件总线，$bus 就是当前应用的 vm
   }
   ......
   })
3. 使用事件总线：
   1. 接收数据：A 组件想接收数据，则在 A 组件中给$bus绑定自定义事件，事件的回调留在A组件自身
    methods(){
        demo(data){.....}
    }
    ......
    mounted(){
        this.$bus.$on("xxxx",this.demo)
      }
   2. 提供数据：this.$bus.$emit("xxxx",数据)
4. 最好在 beforeDestroy 钩子，用$off 去解绑当前组件所用到的事件

## 消息订阅与发布(pubsub)

1. 一种组件间通信的方式，适用于任意组件间通信
2. 使用步骤：
   1. 安装 pubsub： npm i pubsub-js
   2. 引入： import pubsub from "pubsub-js"
   3. 接收数据：A 组件想接收数据，则 A 组件中订阅消息，订阅的回调留在 A 组件自身
      methods(){
      demo(data){......}
      },
      ......
      mounted(){
      this.pid = pubsub.subscribe("xxx",this.demo) //订阅消息
      }
   4. 提供数据：pubsub.publish("xxx",数据)
   5. 最好在 beforeDestroy 钩子，用 PubSub.unsubscribe(pid)去<span style="color:red">取消订阅</span>

## nextTick

1. 语法：this.$nextTick(回调函数)
2. 作用：在下一次 DOM 更新接收后执行其指定的回调
3. 什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行

## Vue 封装的过渡与动画

1.  作用：在插入，更新或移除 DOM 元素时，在合适的时候给元素添加样式类名
2.  图示：

          Enter                            leave
           ||                                ||

    opacity:0 opacity:1 opacity:1 opacity:0
    | | | |
    v-enter v-enter-to v-leave v-leave-to

    ***

                  |                        |
          v-enter-active             v-leave-active

3.  写法：
    1. 准备好样式：
       · 元素进入的样式 1. v-enter：进入的起点 2. v-enter-active: 进入过程中 3. v-enter-to: 进入的终点
       · 元素离开的样式 4. v-leave：离开的起点 5. v-leave-active：离开的过程中 6. v-leave-to： 离开的终点
    2. 使用<transition>包裹要过渡的元素，并配置 name 属性
       <transition name="hello">
       <h1 v-show="isShow">你好啊！</h1>
       </transition>
    3. 备注：若有多个元素需要过渡，则需要使用：<transition-group>,且每个元素都有指定 key 值

## vue 脚手架配置代理

### 方法一

    在vue.config.js中添加如下配置：
    devServer:{
        proxy:"http://localhost:5000"
    }
    说明：
        1. 优点：配置简单，请求资源时直接发给前端(8080)即可
        2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理
        3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器(优先匹配前端资源)

### 方法二

````js
编写vue.config.js配置具体代理规则：

module.exports = {
    devServer:{
        proxy:{
            "/api":{ //匹配所有'/api'开头的请求路径
            target："http://localhost:5000",//代理目标的基础路径
             //用于控制请求头中的host值，为true时默认匹配服务器，为false则匹配本地
            changeOrigin:true,
             // pathRewrite即重新路径，值为对象键值对，正则内容为匹配所有以/api开头的名字重置为空字符串
            pathRewrite:{"^/api":""}
            }
        }
    }
}


    // changeOrigin设置为true时，服务器收到的请求头中的host为，localhost:5000
    // changeOrigin设置为false时，服务器收到请求头中的host为，localhost:8080
    // changeOrigin默认值为true


​```js
````

说明：

​		 1. 优点:可以配置多个代理，且可以灵活的控制请求是否走代理 

​		2. 缺点:配置略微繁琐，请求资源时必须加前缀

## 插槽

作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 **父组件 ==> 子组件**

分类：默认插槽，具名插槽，作用域插槽

使用方式：
1. 默认插槽：

``` Vue

    父组件中:

            <Category>
                <div>html结构1</div>
            </Category>
    
    子组件中:
            <template>
        		<div>
                    <!--定义插槽-->
                    <slot>插槽默认内容</slot>
                </div>
            </template>


2. 具名插槽



    父组件中：

            <Category>
                <template slot="center">
                    <div>html结构1</div>
                </template>

                <template v-slot:footer>
                    <div>html结构2</div>
                </template>
            </Category>
            
    子组件中：
            <template>
                <div>
                    <!--定义插槽--->
                    <slot name="center">插槽默认内容。。。</slot>
                    <slot name="footer">插槽默认内容。。。</slot>
                </div>
            </template>

```
3. 作用域插槽：
    1. 理解：数据据在组件的自身，但根据数据生成的结构需要组件的使用者来决定，(games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定)
    2. 具体编码：
``` Vue
        父组件中：
            <Category>
                <template scope="scopeDate">
                    <!--生成的是ul列表-->
                    <ul>
                        <li v-for="g in scopeDate.games" :key="g">{{g}}</li>
                    </ul>
                </template>
            </Category>

            <Category>
                <template scope="scopeDate">
                    <!--生成的是h4标签-->
                    <h4 v-for="g in scopeDate.games" :key="g">{{g}}</h4>
                </template>
            </Category>
        
        子组件中：
            <template>
                <div>
                    <slot :games="games"></slot>
                </div>
            </template>

            <script>
                export default {
                    name:"Category",
                    porps:["title"],
                    //数据在子组件自身
                    data(){
                        return {
                            games:["红色警戒", "穿越火线", "小龙虾", "牛排"]
                        }
                    }
                }
            </script>
```

## Vuex
### 1. 概念
    在vue中实现集中式状态(数据)管理的一个vue插件，对vue应用中多个组件的共享状态进行集中式的管理(读/写)，也是一种组件间通信的方式，且适用于任意组件间通信。
### 2. 何时使用？
    多个组件需要共享数据时
### 3. 搭建vuex环境
    1. 创建文件： src/store/index.js
``` Vue 
    //引入vue核心库
    import Vue from "vue"
    //引入Vuex
    import Vuex from "vuex"
    //应用vuex插件
    Vue.use(Vuex)

    //准备actions对象-响应组件中用户的动作
    const actions = {}
    //准备mutations对象-修改state中是数据
    const mutations = {}
    //准备state对象-保存具体的数据
    const state = {}

    //创建并暴露store
    export default new Vuex.Store({
    actions,
    mutations,
    state,
})

```
2. 在main.js中创建vm时传入store配置项

``` Vue
    .....
    //引入state
    import store from './store/index'
    .....

    //创建vm
    new Vue({
        el:"#app",
        render:h => h(App),
        store:store,
    })
```

### 4. 基本使用
   1. 初始化数据，配置actions，配置mutations，操作文件store.js
``` Vue
    //引入vue核心库
    import Vue from 'vue'
    //引入vuex
    import Vuex from 'vuex'
    //使用vuex插件
    Vue.use(Vuex)

    const actions ={
        //响应组件中加的动作
        jia(context,value){
            //console.log('actions中的jia被调用了'，mimiStore,value)
            context.commit("JIA",value)
        }
    }

    const mutations = {
        //执行加
        JIA(state,value){
            //console.log('mutations中的JIA被调用了'state,value)
            state.sum += value
        }
    }

    //初始化数据
    const state = {
        sum:0
    }

    //创建并暴露store
    exort default new Vuex.Store({
        actions,
        mutations,
        state,
    })
``` 
   2. 组件中读取vuex中的数据：$store.state.sum
   3. 组件中国修改vuex中的数据：$store.dispatch('action中的方法名'，数据)或 $store.commit('mutations中的方法名'，数据)

   ***备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接写commit***  